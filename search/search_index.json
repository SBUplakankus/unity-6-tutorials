{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Unity 6 Tutorials","text":""},{"location":"#site-overview","title":"Site Overview","text":"<p>Welcome to the Unity 6 Tutorial Series by Massive Melt Media.</p> <p>This site accompanies the video tutorials on YouTube and provides:</p> <ul> <li>Written explanations</li> <li>Code snippets</li> <li>Design rationale</li> <li>Links to full source code</li> </ul> <p>Roadmap</p> <p>This site is brand new and will be updated regularly throughout the year.   My goal is to release a new tutorial every Tuesday alongside work, coursework,   and ongoing game development projects.</p>"},{"location":"#planned-site-contents","title":"Planned Site Contents","text":"Section Focus Experience Level Optimisation Methods Performance &amp; scalability Intermediate Design Patterns Architecture &amp; maintainability Intermediate / Advanced User Interface Modern UI workflows Beginner / Intermediate Gameplay Systems Core mechanics All levels <p>How to use the site</p> <p>Each tutorial page follows the same structure:</p> <ul> <li>Linked YouTube video</li> <li>Concept overview</li> <li>Recommended experience level</li> <li>Pros and trade-offs</li> <li>Beginner approaches it replaces</li> <li>Sample C# code</li> <li>Links to full source files in the repository</li> </ul>"},{"location":"#community-socials","title":"Community &amp; Socials","text":"<p>BlueSky  YouTube  Itch.io  Discord </p> <p>Work In Progress</p> <p>All documentation is written and maintained without the use of AI. I\u2019m constantly learning and improving my own skills, so if you have suggestions, feedback, or areas you think could be improved, feel free to reach out.</p> <p>You can contact me via Discord or BlueSky, or leave a comment directly on the YouTube videos.</p>"},{"location":"topic-template/","title":"${NAME}","text":"<p>Description about ${NAME} and what problem it solves.</p>"},{"location":"topic-template/#tutorial-video","title":"Tutorial Video","text":"<p>Tutorial video for ${NAME}.</p>"},{"location":"topic-template/#recommended-experience","title":"Recommended Experience","text":"<p>Recommended experience level for using ${NAME}.</p> <ul> <li>Unity experience:</li> <li>Familiarity with:</li> <li>Prerequisites (if any):</li> </ul>"},{"location":"topic-template/#using-name","title":"Using ${NAME}","text":""},{"location":"topic-template/#why-use-name","title":"Why Use ${NAME}?","text":"<p>Key reasons to use ${NAME}.</p> <ul> <li>Benefit One</li> </ul> <p>How ${NAME} improves this aspect.</p> <ul> <li>Benefit Two</li> </ul> <p>How ${NAME} improves this aspect.</p> <ul> <li>Benefit Three</li> </ul> <p>How ${NAME} improves this aspect.</p> <ul> <li>Benefit Four</li> </ul> <p>How ${NAME} improves this aspect.</p>"},{"location":"topic-template/#common-use-case-example","title":"Common Use Case Example","text":"<p>A practical example of where ${NAME} is useful.</p> <ul> <li>Context</li> <li>Problem being solved</li> <li>Why ${NAME} fits this scenario</li> </ul>"},{"location":"topic-template/#beginner-method-replacement","title":"Beginner Method Replacement","text":"<p>The beginner-friendly approach that ${NAME} replaces.</p> <ul> <li>What beginners typically do</li> <li>Why it works at first</li> <li>Where ${NAME} becomes the better choice</li> </ul>"},{"location":"topic-template/#when-not-to-use-name","title":"When Not to Use ${NAME}","text":"<p>Situations where ${NAME} may be unnecessary or overkill.</p> <ul> <li>Simpler alternatives</li> <li>Trade-offs to consider</li> </ul>"},{"location":"topic-template/#name-system-diagram","title":"${NAME} System Diagram","text":"<p>System diagram illustrating how ${NAME} works.</p> <p>Mermaid diagram goes here.</p> <p>Explain: - Key relationships - Data flow - Responsibilities</p>"},{"location":"topic-template/#name-code-snippet","title":"${NAME} Code Snippet","text":"<p>C# example showing ${NAME} in action.</p> <p>Notes: - Key design decisions - Common pitfalls - Optional variations</p>"},{"location":"topic-template/#small-video-code-overview","title":"Small Video Code Overview","text":"<p>Overview of how ${NAME} is implemented in the tutorial video.</p> <ul> <li>What is built</li> <li>What to focus on while watching</li> <li>Any shortcuts or assumptions made</li> </ul> <p>Source files: - Assets/... - GitHub link to folder or commit</p>"},{"location":"topic-template/#closing-thoughts","title":"Closing Thoughts","text":"<p>Final thoughts on ${NAME}.</p> <ul> <li>When it shines</li> <li>When to avoid it</li> <li>What to explore next</li> </ul>"},{"location":"optimisation/update-manager/","title":"Game Update Manager","text":""},{"location":"optimisation/update-manager/#overview","title":"Overview","text":"<p>A Custom Game Update Manager is a common design choice in intermediate - large sized games that have hundreds or thousands of objects calling <code>Update()</code> each frame. It allows us to remove the overhead from the Unity base <code>Update()</code> and set different update priority tiers so everything doesn't need to be called each frame.</p>"},{"location":"optimisation/update-manager/#tutorial-video","title":"Tutorial Video","text":"<p>Tutorial video for Game Update Manager.</p>"},{"location":"optimisation/update-manager/#recommended-experience","title":"Recommended Experience","text":"<p>I would consider the Custom Update Manager to be an Intermediate topic in Unity.</p> <p>Its implementation is very straight forward, but it requires an understanding of some basic concepts and  isn't necessary on smaller scale beginner projects. </p> <p>I recommend you go into this with a base understanding of:</p> <ul> <li>C# Interfaces</li> <li>Unities Lifecycle Calls ie. <code>Update()</code>, <code>FixedUpdate()</code>, <code>LateUpdate()</code></li> <li>Understanding of memory Allocation and De-Allocation with <code>OnEnable()</code> and <code>OnDisable()</code></li> <li>Understanding of the Singleton Pattern and how Instances work</li> </ul>"},{"location":"optimisation/update-manager/#using-a-custom-game-update-manager","title":"Using a Custom Game Update Manager","text":""},{"location":"optimisation/update-manager/#why-use-one","title":"Why Use One?","text":"<ul> <li> <p> Performance</p> <p>Less overhead than the base <code>Update()</code> call which saves CPU Performance.</p> </li> <li> <p> Prioritisation</p> <p>Specify how often <code>Update()</code> needs to be called in each script.</p> </li> <li> <p> Cache Efficiency</p> <p>Groups similar priority updates together compared to <code>Update()</code> being scattered across multiple components.</p> </li> <li> <p> Debugging and Profiling</p> <p>Centralised update logic makes it easier to debug and profile performance</p> </li> </ul>"},{"location":"optimisation/update-manager/#common-use-cases","title":"Common Use Cases","text":"<p>Some common use cases for a Custom Update Manager would include:</p> <ul> <li>Mobile, VR and XR Games where CPU optimization and performance is critical.</li> <li>Games with hundreds of active entities such as a Tower Defence or RTS Game.</li> <li>A City Builder game with hundreds of update calls for NPC's, vehicles and buildings.</li> </ul>"},{"location":"optimisation/update-manager/#beginner-method-replacement","title":"Beginner Method Replacement","text":"<p>The beginner-friendly approach that Game Update Manager replaces would just be using the Unity MonoBehaviour <code>Update()</code> for every component in the game. </p>"},{"location":"optimisation/update-manager/#when-not-to-use-game-update-manager","title":"When Not to Use Game Update Manager","text":"<p>Situations where Game Update Manager may be unnecessary or overkill would be for small projects or rapid prototypes. The overhead is negligible unless Update is being called on many different components.</p>"},{"location":"optimisation/update-manager/#game-update-manager-system-diagram","title":"Game Update Manager System Diagram","text":"<p>Here you can see the flow of how the system works. The key feature of an Update Manager is the Update Priority which you define when registering.</p> <pre><code>    flowchart TD\n    Component[Component]\n    IUpd[IUpdateable]\n    Register[Register with Manager]\n    Manager[GameUpdateManager]\n\n    High[High Registry]\n    Medium[Medium Registry]\n    Low[Low Registry]\n\n    IterateH[Iterate High]\n    IterateM[Iterate Medium]\n    IterateL[Iterate Low]\n\n    OnUpdate[Call OnUpdate]\n\n    Component --&gt; IUpd\n    IUpd --&gt; Register\n    Register --&gt; Manager\n\n    Manager --&gt; High\n    Manager --&gt; Medium\n    Manager --&gt; Low\n\n    High --&gt; IterateH --&gt; OnUpdate\n    Medium --&gt; IterateM --&gt; OnUpdate\n    Low --&gt; IterateL --&gt; OnUpdate\n\n</code></pre>"},{"location":"optimisation/update-manager/#game-update-manager-code","title":"Game Update Manager Code","text":""},{"location":"optimisation/update-manager/#code-examples","title":"Code Examples","text":"<p>IUpdateable Interface</p> <p>Here we have the interface that Components inherit so they can have access to the <code>OnUpdate()</code> method. <pre><code>public interface IUpdateable()\n{\n    public void OnUpdate(float deltaTime);\n}\n</code></pre></p> <p>Update Priority Enum</p> <p>We create an Update Priority enum so we can safely separate our components into lists to be called at their set rate. This is passed through when registering so the component can be added to the related list. <pre><code>public enum UpdatePriority\n{\n    Low,\n    Medium,\n    High\n}\n</code></pre></p> <p>Game Update Manager</p> <p>Here we have the main manager file which is a singleton that handles registering, unregistering, and updating every component that uses the <code>IUpdateable</code> interface. <pre><code>    public class GameUpdateManager : MonoBehaviour\n    {\n        public static GameUpdateManager Instance { get; private set; }\n\n        private readonly List&lt;IUpdateable&gt; _highPriorityUpdates = new();\n        private readonly List&lt;IUpdateable&gt; _mediumPriorityUpdates = new(); \n        private readonly List&lt;IUpdateable&gt; _lowPriorityUpdates = new();\n\n        private const float MediumPriorityInterval = 0.2f;\n        private const float LowPriorityInterval = 0.4f;\n        private float _mediumPriorityTimer;\n        private float _lowPriorityTimer;\n\n        private void UpdateHighPriority()\n        {\n            for (var i = 0; i &lt; _highPriorityUpdates.Count; i++)\n            {\n                _highPriorityUpdates[i].OnUpdate(Time.deltaTime);\n            }\n        }\n\n        private void UpdateMediumPriority()\n        {\n            _mediumPriorityTimer += Time.deltaTime;\n            if (!(_mediumPriorityTimer &gt;= MediumPriorityInterval)) return;\n\n            for (var i = 0; i &lt; _mediumPriorityUpdates.Count; i++)\n            {\n                _mediumPriorityUpdates[i].OnUpdate(_mediumPriorityTimer);\n            }\n            _mediumPriorityTimer = 0f;\n        }\n\n        private void UpdateLowPriority()\n        {\n            _lowPriorityTimer += Time.deltaTime;\n            if (!(_lowPriorityTimer &gt;= LowPriorityInterval)) return;\n\n            for (var i = 0; i &lt; _lowPriorityUpdates.Count; i++)\n            {\n                _lowPriorityUpdates[i].OnUpdate(_lowPriorityTimer);\n            }\n            _lowPriorityTimer = 0f;\n        }\n\n        public void Register(IUpdateable updateable, UpdatePriority priority)\n        {\n            switch (priority)\n            {\n                case UpdatePriority.High:\n                    _highPriorityUpdates.Add(updateable);\n                    break;\n                case UpdatePriority.Medium:\n                    _mediumPriorityUpdates.Add(updateable);\n                    break;\n                case UpdatePriority.Low:\n                    _lowPriorityUpdates.Add(updateable);\n                    break;\n                default:\n                    throw new ArgumentOutOfRangeException(nameof(priority), priority, null);\n            }\n        }\n\n        public void Unregister(IUpdateable updateable)\n        {\n            if (_highPriorityUpdates.Remove(updateable)) return;\n            if (_mediumPriorityUpdates.Remove(updateable)) return;\n            _lowPriorityUpdates.Remove(updateable);\n        }\n\n        private void Awake()\n        {\n            if (Instance != null &amp;&amp; Instance != this)\n            {\n                Destroy(gameObject);\n                return;\n            }\n\n            Instance = this;\n        }\n\n        private void Update()\n        {\n            UpdateHighPriority();\n            UpdateMediumPriority();\n            UpdateLowPriority();\n        }\n    }\n</code></pre></p>"},{"location":"optimisation/update-manager/#tutorial-video-source-files","title":"Tutorial Video Source Files","text":"<ul> <li>GameUpdateManager</li> <li>IUpdateable</li> <li>UpdatePriority</li> <li>DemoController</li> </ul>"},{"location":"optimisation/update-manager/#final-thoughts","title":"Final Thoughts","text":"<p>Once you get the hang of using your own custom Game Update Manager, it becomes very fast and easy to implement. It's a nice way to learn how to start doing your own thing in an engine like Unity where things are made very easy for you in places.  That does not mean they are made optimally though and this is just one of a few tricks professional studios use to squeeze as much performance as they can out of it.</p>"}]}